<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="lYnn">
  <!-- Open Graph Data -->
  <meta property="og:title" content="JVM"/>
  <meta property="og:description" content="My Blog" />
  <meta property="og:site_name" content="lYnn"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="lYnn" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>lYnn</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">JVM</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  首页
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  归档
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/YouNglyn00009" target="_blank" rel="noopener">
                  
                  Github
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By lYnn</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-12-21</span>
            <span class="time">00:18:41</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">分类: 

<a href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            标签: 

<a class="tag" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h2 id="一、JVM运行时数据区"><a href="#一、JVM运行时数据区" class="headerlink" title="一、JVM运行时数据区"></a>一、JVM运行时数据区</h2><ol>
<li><p>程序计数器: 简单的说，线程计数器就是为了记录每个线程执行到哪一行的一块非常小的区域，所以说每个线程都有一个程序计数器为线程服务。 如果线程执行java方法，则程序计数器存放的是java方法的指令地址；如果执行本地的native方法，程序计数器为空。 程序计数器不会出现OOM错误。</p>
</li>
<li><p>虚拟机栈: 线程私有的，虚拟机栈简称栈，是表示java方法执行的内存模型，每个java方法执行时都会创建一个栈帧，每个栈帧中存储了<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>方法出口</strong>等信息，<strong>局部变量表在编译器就对其内存进行了分配</strong>。</p>
<p>异常情况</p>
<ul>
<li>栈深度大于虚拟机允许的最大深度抛出StackOverflowError</li>
<li>内存不足时抛出OutOfMemoryError</li>
</ul>
</li>
<li><p>本地方法栈: 与虚拟机栈类似，只是本地方法栈为本地方法服务。</p>
</li>
<li><p>方法区: 所有线程共享，存储已经被虚拟机加载的类信息、常量、静态变量等数据</p>
</li>
<li><p>堆: 所有线程共享，java内存中最大的一块区域，虚拟机启动时就被创建。堆内存中主要存放对象的实例和数据等信息。</p>
</li>
</ol>
<a id="more"></a>


<h4 id="下图为jdk1-7之前的内存数据区划分"><a href="#下图为jdk1-7之前的内存数据区划分" class="headerlink" title="下图为jdk1.7之前的内存数据区划分"></a>下图为jdk1.7之前的内存数据区划分</h4><p><img src="/img/jvm/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpeg" alt="avator"></p>
</br>

<h4 id="下图为jdk8以后的内存数据区结构"><a href="#下图为jdk8以后的内存数据区结构" class="headerlink" title="下图为jdk8以后的内存数据区结构"></a>下图为jdk8以后的内存数据区结构</h4><p><img src="/img/jvm/1.8%E6%95%B0%E6%8D%AE%E5%8C%BA.jpeg" alt="avator"></p>
<h2 id="二、栈帧中对象的引用方式"><a href="#二、栈帧中对象的引用方式" class="headerlink" title="二、栈帧中对象的引用方式"></a>二、栈帧中对象的引用方式</h2><p>栈帧中的局部变量表存储的事对象的引用和一些基本的数据类型，但是栈帧中使用的对象实例则存储在堆内存中。局部变量表的对象引用一般有两种方式:</p>
<ul>
<li>使用句柄方式: 在堆内存中有一块区域作为句柄池，用来存放对象实例的指针和对象类型数据的指针，指向堆中的对象实例和方法区的对象类型数据。 这种方式的优点是比较灵活，在gc过程中，对象移动时只改变句柄池的对象指针即可。</li>
</ul>
<p><img src="/img/jvm/%E5%8F%A5%E6%9F%84%E6%96%B9%E5%BC%8F.png" alt="avator"></p>
<ul>
<li>直接引用方式: 局部变量表的对象引用直接存储对象实例的指针，指向堆内存的对象实例，而对象类型数据则存在对象实例中。这种方式的优点是性能较句柄方式更好，节省了一次指针寻找地址的时间。</li>
</ul>
<p><img src="/img/jvm/%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8.png" alt="avator"></p>
<h2 id="JMM（java内存模型）"><a href="#JMM（java内存模型）" class="headerlink" title="JMM（java内存模型）"></a>JMM（java内存模型）</h2><ul>
<li><p>JMM的主要目标： 定义程序中变量的访问规则</p>
</li>
<li><p>JMM保证： 由于各个线程访问主内存中数据的先后顺序无法保证，所以需要JMM保证<strong>原子性</strong>，<strong>可见性</strong>，<strong>有序性</strong></p>
<h3 id="JMM保证"><a href="#JMM保证" class="headerlink" title="JMM保证"></a>JMM保证</h3><ul>
<li>原子性： 除long，double以外的基本数据类型读写和synchronized代码块可保证</li>
<li>可见性： synchronized和volatile可保证，volatile可以强制将变量的赋值刷新到主内存中，变量的读取会从主内存中重新加载,这样就能保证不同的线程读取到的数据都是最新的</li>
<li>有序性： volatile和happens-before原则</li>
</ul>
</li>
</ul>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><ul>
<li><strong>加载与卸载流程：</strong> 加载（文件到内存）-&gt; 验证（包括文件格式，元数据，字节码，符号引用） -&gt; 准备（为类变量，即static修饰的静态变量分配内存）-&gt; 解析（引用替换，字段解析，接口解析，方法解析）-&gt; 初始化（静态代码块，静态变量）-&gt; 使用（实例化）-&gt; 卸载（GC）</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li><p>BootStrap ClassLoader 负责加载JAVA_HOME/lib目录下的类</p>
</li>
<li><p>ExtClassLoader 负责加载JAVA_HOME/lib/ext目录下的类</p>
</li>
<li><p>AppClassLoader 负责加载 java -classpath指定目录下的类</p>
</li>
<li><p>Custom ClassLoader 自定义类加载器</p>
<h3 id="双亲委派模式："><a href="#双亲委派模式：" class="headerlink" title="双亲委派模式："></a>双亲委派模式：</h3><ul>
<li>一个类加载器在加载类时，先把这个类委托给类加载器的父类加载器加载，如果父类加载器还存在父类加载器，则继续向上委托,直到顶层的启动类加载器;如果父类加载器能够加载类，则成功返回，如果父类加载器不能加载类，则子类进行加载</li>
<li>优点： 1. 避免类被重复加载； 2. 避免javaApi被篡改</li>
</ul>
</li>
</ul>
<h2 id="GC-垃圾回收"><a href="#GC-垃圾回收" class="headerlink" title="GC(垃圾回收)"></a>GC(垃圾回收)</h2><h3 id="分代管理（方便垃圾回收）"><a href="#分代管理（方便垃圾回收）" class="headerlink" title="分代管理（方便垃圾回收）"></a>分代管理（方便垃圾回收）</h3><ul>
<li>年轻代: eden, Survivor1, Survivor2，对象一般在eden区生成，当eden区内存满了之后，对象会在两个survivor去交替保存</li>
<li>老年代：存放从年轻代来的存活时间较长的对象</li>
<li>持久代：保存类信息等内容，</li>
</ul>
<h3 id="垃圾回收（年轻代和老年代）"><a href="#垃圾回收（年轻代和老年代）" class="headerlink" title="垃圾回收（年轻代和老年代）"></a>垃圾回收（年轻代和老年代）</h3><ul>
<li>引用计数法</li>
<li>标记清除算法：分为两个阶段： 1.标记对象 2.清除对象， 缺点：会产生内存碎片</li>
<li>复制算法： from和to大小相同的内存空间，分配对象时只分配到from块，回收的时候把存货对象复制到to块，并清空from块,然后互相交换</li>
</ul>
<h4 id="CMS算法（标记清除）-jdk1-7以前主流的垃圾回收算法"><a href="#CMS算法（标记清除）-jdk1-7以前主流的垃圾回收算法" class="headerlink" title="CMS算法（标记清除） jdk1.7以前主流的垃圾回收算法"></a>CMS算法（标记清除） jdk1.7以前主流的垃圾回收算法</h4><h4 id="G1算法（复制算法）-JDK1-9后JVM的默认算法"><a href="#G1算法（复制算法）-JDK1-9后JVM的默认算法" class="headerlink" title="G1算法（复制算法） JDK1.9后JVM的默认算法"></a>G1算法（复制算法） JDK1.9后JVM的默认算法</h4><h4 id="ZGC-最新的回收算法-效率非常高"><a href="#ZGC-最新的回收算法-效率非常高" class="headerlink" title="ZGC 最新的回收算法 效率非常高"></a>ZGC 最新的回收算法 效率非常高</h4><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol>
<li><p>简单描述一下JVM的内存模型</p>
<ul>
<li>本地方法栈： 指native方法</li>
<li>方法区：存放静态变量，常量等</li>
<li>堆：存放所有对象的实例</li>
<li>栈：</li>
<li>程序计数器：为java方法服务</li>
<li>栈，方法区和程序计数器是线程独享的</li>
<li>堆和方法区是线程共享的</li>
</ul>
</li>
<li><p>什么情况下回触发FullGc</p>
<ul>
<li>年轻代晋升</li>
<li>老年代空间不足</li>
<li>永久代空间不足</li>
</ul>
</li>
<li><p>JAVA类加载器有几种</p>
<ul>
<li>BootStrap ClassLoader 加载JAVA_HOME/lib</li>
<li>ExtClassLoader  加载JAVA_HOME/lib/ext</li>
<li>AppClassLoader  记载 java -classpath指定目录的类</li>
<li>Custom ClassLoader 自定义加载器</li>
</ul>
</li>
<li><p>双亲委派机制的加载流程是怎样处的，有什么好处</p>
<ul>
<li>类加载时，类加载器首先会将要加载的类交给父类去加载，如果父类还有父类加载器，则继续向上委派，直到顶层的<strong>启动类</strong>加载器加载; 如果加载成功，则返回，如果未成功，则由子类加载器加载</li>
<li>好处：1.类不会被重复加载 2.JAVAApi不会被篡改</li>
</ul>
</li>
<li><p>1.8为什么用Metaspace替换调PermGen？ Metaspace保存在哪里</p>
</li>
<li><p>编译器会对指令做哪些优化？（简单描述编译器的指令重排）</p>
</li>
<li><p>volatile可以解决什么问题？如何做到的</p>
<ul>
<li>强制主内存读写同步</li>
<li>防止指令重排序</li>
</ul>
</li>
<li><p>GC的分代回收</p>
</li>
<li><p>G1垃圾回收算法与CMS的区别有哪些？</p>
</li>
<li><p>对象引用有哪几种方式，有什么特点</p>
<ul>
<li>强引用</li>
<li>弱引用</li>
<li>软引用</li>
<li>虚引用</li>
</ul>
</li>
<li><p>使用过那些JVM调试工具，主要分析哪些内容？</p>
</li>
</ol>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Powered By <b><a target="_blank" href="https://hexo.io/">Hexo</a></b>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>


<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="lYnn">
  <!-- Open Graph Data -->
  <meta property="og:title" content="JVM"/>
  <meta property="og:description" content="My Blog" />
  <meta property="og:site_name" content="lYnn"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="lYnn" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>lYnn</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">JVM</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  首页
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  归档
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/YouNglyn00009" target="_blank" rel="noopener">
                  
                  Github
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By lYnn</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-12-21</span>
            <span class="time">11:09:28</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">分类: 

<a href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            标签: 

<a class="tag" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h2 id="一、JVM运行时数据区"><a href="#一、JVM运行时数据区" class="headerlink" title="一、JVM运行时数据区"></a>一、JVM运行时数据区</h2><ol>
<li><p>程序计数器: 简单的说，线程计数器就是为了记录每个线程执行到哪一行的一块非常小的区域，所以说每个线程都有一个程序计数器为线程服务。 如果线程执行java方法，则程序计数器存放的是java方法的指令地址；如果执行本地的native方法，程序计数器为空。</p>
</li>
<li><p>虚拟机栈: 线程私有的，虚拟机栈简称栈，是表示java方法执行的内存模型，每个java方法执行时都会创建一个栈帧，每个栈帧中存储了<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>方法出口</strong>等信息，<strong>局部变量表在编译器就对其内存进行了分配</strong>。</p>
<p>异常情况</p>
<ul>
<li>栈深度大于虚拟机允许的最大深度抛出StackOverflowError</li>
<li>内存不足时抛出OutOfMemoryError</li>
</ul>
</li>
<li><p>本地方法栈: 与虚拟机栈类似，只是本地方法栈为本地方法服务。</p>
</li>
<li><p>方法区: 所有线程共享，存储已经被虚拟机加载的类信息、常量、静态变量等数据</p>
</li>
<li><p>堆: 所有线程共享，java内存中最大的一块区域，虚拟机启动时就被创建。堆内存中主要存放对象的实例和数据等信息。</p>
</li>
</ol>
<a id="more"></a>


<h4 id="下图为jdk1-7之前的内存数据区划分"><a href="#下图为jdk1-7之前的内存数据区划分" class="headerlink" title="下图为jdk1.7之前的内存数据区划分"></a>下图为jdk1.7之前的内存数据区划分</h4><p><img src="/img/jvm/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpeg" alt="jvm运行时数据区"></p>
</br>

<h4 id="下图为jdk8以后的内存数据区结构"><a href="#下图为jdk8以后的内存数据区结构" class="headerlink" title="下图为jdk8以后的内存数据区结构"></a>下图为jdk8以后的内存数据区结构</h4><p><img src="/img/jvm/1.8%E6%95%B0%E6%8D%AE%E5%8C%BA.jpeg" alt="avator"></p>
<h2 id="二、栈帧中对象的引用方式"><a href="#二、栈帧中对象的引用方式" class="headerlink" title="二、栈帧中对象的引用方式"></a>二、栈帧中对象的引用方式</h2><p>栈帧中的局部变量表存储的事对象的引用和一些基本的数据类型，但是栈帧中使用的对象实例则存储在堆内存中。局部变量表的对象引用一般有两种方式:</p>
<ul>
<li>使用句柄方式: 在堆内存中有一块区域作为句柄池，用来存放对象实例的指针和对象类型数据的指针，指向堆中的对象实例和方法区的对象类型数据。 这种方式的优点是比较灵活，在gc过程中，对象移动时只改变句柄池的对象指针即可。</li>
</ul>
<p><img src="/img/jvm/%E5%8F%A5%E6%9F%84%E6%96%B9%E5%BC%8F.png" alt="句柄方式"></p>
<ul>
<li>直接引用方式: 局部变量表的对象引用直接存储对象实例的指针，指向堆内存的对象实例，而对象类型数据则存在对象实例中。这种方式的优点是性能较句柄方式更好，节省了一次指针寻找地址的时间。</li>
</ul>
<p><img src="/img/jvm/%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8.png" alt="直接引用"></p>
<h2 id="三、堆区"><a href="#三、堆区" class="headerlink" title="三、堆区"></a>三、堆区</h2><p> 堆区分为新生代和老年代。而新生代则分为Eden区和survivor1以及survivor2</p>
<p> 新创建的对象被存放在新生代，但是如果对象超大的话，会直接存放到老年代（需要设置jvm参数：<code>-XX:PretenureSizeThreshold</code>）。</p>
<p><img src="/img/jvm/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E5%88%A4%E5%AE%9A%E6%B5%81%E7%A8%8B.png" alt="创建对象存储区域判定流程"></p>
<h2 id="四、虚拟机参数"><a href="#四、虚拟机参数" class="headerlink" title="四、虚拟机参数"></a>四、虚拟机参数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-Xmx -Xms</td>
<td>堆内存的最大值和最小值，如果设置了最大和最小值，jvm启动后会开辟最小内存，经过数次GC后，还不能满足程序的运行需要，才会逐渐扩大内存。-Xms默认为物理内存的1/64，最小为1M，-Xmx默认为物理内存的1/4或者1G，最小为2M，两者单位可自定义，若不置顶单位，默认为字节。</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代的内存大小，官方推荐新生代占java堆的3/8</td>
</tr>
<tr>
<td>-XX:NewSize</td>
<td>设置年轻代大小</td>
</tr>
<tr>
<td>-XX:MaxNewSize</td>
<td>设置年轻代最大值</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>新生代和老年代的比例</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>两个survivor区和eden区的比例</td>
</tr>
<tr>
<td>-XX:PermSize -XX:MaxPermSize</td>
<td>设置永久代的内存大小和最大值。MaxPermSize默认为物理内存的1/4</td>
</tr>
<tr>
<td>-Xss</td>
<td>栈的大小，默认1M</td>
</tr>
<tr>
<td>-XXThreadStackSize</td>
<td>设置线程栈的大小</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>设置垃圾的最大年龄，如果为0，则年轻代对象不会在eden区生成后不经过survivor区，直接进入老年代</td>
</tr>
<tr>
<td>-XX:PretenureSizeThreshold</td>
<td>设置对象超过多大时直接在老年代进行内存分配，默认为0</td>
</tr>
<tr>
<td>-XX:+HeapDumpOnOutMemoryError</td>
<td>发生OOM错误时，以文件形式导出堆信息。</td>
</tr>
<tr>
<td>-XX:+HeapDumpPath</td>
<td>OOM错误时导出的文件路径</td>
</tr>
<tr>
<td>-XX:OnOutOfMemoryError</td>
<td>当系统产生OOM时，执行一个指定的脚本，这个脚本可以是任意功能的。比如生成当前线程的dump文件，或者是发送邮件和重启系统。</td>
</tr>
</tbody></table>
<h2 id="五、垃圾回收"><a href="#五、垃圾回收" class="headerlink" title="五、垃圾回收"></a>五、垃圾回收</h2><h3 id="1、判断对象是否已死"><a href="#1、判断对象是否已死" class="headerlink" title="1、判断对象是否已死"></a>1、判断对象是否已死</h3><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h4><p>对象会存一个引用计数器，每当有一个地方引用它，对象的计数器就+1，引用失效时，计数器-1；当计数器为0时，就代表对象不再被引用。<br><br><b>现在常用的JVM没有使用引用计数法，主要原因就是引用计数法无法解决对象的循环引用问题</b></p>
<h4 id="1-2-可达性分析算法（JVM使用的）"><a href="#1-2-可达性分析算法（JVM使用的）" class="headerlink" title="1.2 可达性分析算法（JVM使用的）"></a>1.2 可达性分析算法（JVM使用的）</h4><ul>
<li>GC Roots对象：<ul>
<li>虚拟机栈(栈桢中的本地变量表)中的引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>本地方法栈中（native方法）的引用的对象</li>
</ul>
</li>
</ul>
<p>可达性分析算法：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，当一个对象到GC Roots没有任何引用链连接时，说明该对象已死。</p>
<h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a>2.1 标记-清除算法</h4><p>分为标记和清除两个阶段，先标记出所有需要需要回收的对象，标记完成后统一回收所有被标记的对象。标记-清除算法的缺点：</p>
<ul>
<li>效率低</li>
<li>产生较多的内存碎片，在系统需要分配大内存对象时可能会无法找到足够内存而出发另一次GC</li>
</ul>
<p><img src="/img/jvm/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg" alt="标记-清除算法"></p>
<h4 id="2-2-标记-整理算法-老年代回收算法"><a href="#2-2-标记-整理算法-老年代回收算法" class="headerlink" title="2.2 标记-整理算法(老年代回收算法)"></a>2.2 标记-整理算法(老年代回收算法)</h4><p>与标记-清除算法前期方式一直，标记完需要回收的对象后，将存活对象移向另一端，这样存活的对象就时一整块连续的内存，将这些存活对象以外的直接批量清除即可。</p>
<p><img src="/img/jvm/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.jpg" alt="标记-整理算法"></p>
<h4 id="2-3-复制算法-新生代回收算法"><a href="#2-3-复制算法-新生代回收算法" class="headerlink" title="2.3 复制算法(新生代回收算法)"></a>2.3 复制算法(新生代回收算法)</h4><p>每次使用时只使用Eden和其中的一块Survivor区，回收时将Eden和Survivor1中还存活的对象一次性复制到Survivor2区，再将Eden和Survivor1区的对象清除。该算法的好处：</p>
<ul>
<li>简单高效（空间换时间）</li>
<li>不会出现内存碎片，每次只操作一半区域。</li>
</ul>
<p><img src="/img/jvm/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg" alt="复制算法"></p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Powered By <b><a target="_blank" href="https://hexo.io/">Hexo</a></b>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>


<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="lYnn">
  <!-- Open Graph Data -->
  <meta property="og:title" content="JVM"/>
  <meta property="og:description" content="My Blog" />
  <meta property="og:site_name" content="lYnn"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="lYnn" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>lYnn</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">JVM</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  首页
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  归档
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/YouNglyn00009" target="_blank" rel="noopener">
                  
                  Github
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By lYnn</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-12-21</span>
            <span class="time">23:07:05</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">分类: 

<a href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            标签: 

<a class="tag" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h2 id="JVM内存区"><a href="#JVM内存区" class="headerlink" title="JVM内存区"></a>JVM内存区</h2><ul>
<li>程序计数器: 只为java方法服务，执行native方法时，计数器为空</li>
<li>方法区: 又叫非堆区，存放已加载的常量，静态变量等</li>
<li>堆：内存中最大的一块，被所有线程共享，存放所有对象实例, 当堆内存空间不足，会抛出OOM异常</li>
<li>栈：</li>
<li>本地方法栈：指native方法</li>
</ul>
<ol>
<li>线程独占： 栈，本地方法栈（native方法），程序计数器</li>
<li>线程共享： 堆，方法区</li>
</ol>
<a id="more"></a>

<h2 id="JMM（java内存模型）"><a href="#JMM（java内存模型）" class="headerlink" title="JMM（java内存模型）"></a>JMM（java内存模型）</h2><ul>
<li><p>JMM的主要目标： 定义程序中变量的访问规则</p>
</li>
<li><p>JMM保证： 由于各个线程访问主内存中数据的先后顺序无法保证，所以需要JMM保证<strong>原子性</strong>，<strong>可见性</strong>，<strong>有序性</strong></p>
<h3 id="JMM保证"><a href="#JMM保证" class="headerlink" title="JMM保证"></a>JMM保证</h3><ul>
<li>原子性： 除long，double以外的基本数据类型读写和synchronized代码块可保证</li>
<li>可见性： synchronized和volatile可保证，volatile可以强制将变量的赋值刷新到主内存中，变量的读取会从主内存中重新加载,这样就能保证不同的线程读取到的数据都是最新的</li>
<li>有序性： volatile和happens-before原则</li>
</ul>
</li>
</ul>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><ul>
<li><strong>加载与卸载流程：</strong> 加载（文件到内存）-&gt; 验证（包括文件格式，元数据，字节码，符号引用） -&gt; 准备（为类变量，即static修饰的静态变量分配内存）-&gt; 解析（引用替换，字段解析，接口解析，方法解析）-&gt; 初始化（静态代码块，静态变量）-&gt; 使用（实例化）-&gt; 卸载（GC）</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li><p>BootStrap ClassLoader 负责加载JAVA_HOME/lib目录下的类</p>
</li>
<li><p>ExtClassLoader 负责加载JAVA_HOME/lib/ext目录下的类</p>
</li>
<li><p>AppClassLoader 负责加载 java -classpath指定目录下的类</p>
</li>
<li><p>Custom ClassLoader 自定义类加载器</p>
<h3 id="双亲委派模式："><a href="#双亲委派模式：" class="headerlink" title="双亲委派模式："></a>双亲委派模式：</h3><ul>
<li>一个类加载器在加载类时，先把这个类委托给类加载器的父类加载器加载，如果父类加载器还存在父类加载器，则继续向上委托,直到顶层的启动类加载器;如果父类加载器能够加载类，则成功返回，如果父类加载器不能加载类，则子类进行加载</li>
<li>优点： 1. 避免类被重复加载； 2. 避免javaApi被篡改</li>
</ul>
</li>
</ul>
<h2 id="GC-垃圾回收"><a href="#GC-垃圾回收" class="headerlink" title="GC(垃圾回收)"></a>GC(垃圾回收)</h2><h3 id="分代管理（方便垃圾回收）"><a href="#分代管理（方便垃圾回收）" class="headerlink" title="分代管理（方便垃圾回收）"></a>分代管理（方便垃圾回收）</h3><ul>
<li>年轻代: eden, Survivor1, Survivor2，对象一般在eden区生成，当eden区内存满了之后，对象会在两个survivor去交替保存</li>
<li>老年代：存放从年轻代来的存活时间较长的对象</li>
<li>持久代：保存类信息等内容，</li>
</ul>
<h3 id="垃圾回收（年轻代和老年代）"><a href="#垃圾回收（年轻代和老年代）" class="headerlink" title="垃圾回收（年轻代和老年代）"></a>垃圾回收（年轻代和老年代）</h3><ul>
<li>引用计数法</li>
<li>标记清除算法：分为两个阶段： 1.标记对象 2.清除对象， 缺点：会产生内存碎片</li>
<li>复制算法： from和to大小相同的内存空间，分配对象时只分配到from块，回收的时候把存货对象复制到to块，并清空from块,然后互相交换</li>
</ul>
<h4 id="CMS算法（标记清除）-jdk1-7以前主流的垃圾回收算法"><a href="#CMS算法（标记清除）-jdk1-7以前主流的垃圾回收算法" class="headerlink" title="CMS算法（标记清除） jdk1.7以前主流的垃圾回收算法"></a>CMS算法（标记清除） jdk1.7以前主流的垃圾回收算法</h4><h4 id="G1算法（复制算法）-JDK1-9后JVM的默认算法"><a href="#G1算法（复制算法）-JDK1-9后JVM的默认算法" class="headerlink" title="G1算法（复制算法） JDK1.9后JVM的默认算法"></a>G1算法（复制算法） JDK1.9后JVM的默认算法</h4><h4 id="ZGC-最新的回收算法-效率非常高"><a href="#ZGC-最新的回收算法-效率非常高" class="headerlink" title="ZGC 最新的回收算法 效率非常高"></a>ZGC 最新的回收算法 效率非常高</h4><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol>
<li><p>简单描述一下JVM的内存模型</p>
<ul>
<li>本地方法栈： 指native方法</li>
<li>方法区：存放静态变量，常量等</li>
<li>堆：存放所有对象的实例</li>
<li>栈：</li>
<li>程序计数器：为java方法服务</li>
<li>栈，方法区和程序计数器是线程独享的</li>
<li>堆和方法区是线程共享的</li>
</ul>
</li>
<li><p>什么情况下回触发FullGc</p>
<ul>
<li>年轻代晋升</li>
<li>老年代空间不足</li>
<li>永久代空间不足</li>
</ul>
</li>
<li><p>JAVA类加载器有几种</p>
<ul>
<li>BootStrap ClassLoader 加载JAVA_HOME/lib</li>
<li>ExtClassLoader  加载JAVA_HOME/lib/ext</li>
<li>AppClassLoader  记载 java -classpath指定目录的类</li>
<li>Custom ClassLoader 自定义加载器</li>
</ul>
</li>
<li><p>双亲委派机制的加载流程是怎样处的，有什么好处</p>
<ul>
<li>类加载时，类加载器首先会将要加载的类交给父类去加载，如果父类还有父类加载器，则继续向上委派，直到顶层的<strong>启动类</strong>加载器加载; 如果加载成功，则返回，如果未成功，则由子类加载器加载</li>
<li>好处：1.类不会被重复加载 2.JAVAApi不会被篡改</li>
</ul>
</li>
<li><p>1.8为什么用Metaspace替换调PermGen？ Metaspace保存在哪里</p>
</li>
<li><p>编译器会对指令做哪些优化？（简单描述编译器的指令重排）</p>
</li>
<li><p>volatile可以解决什么问题？如何做到的</p>
<ul>
<li>强制主内存读写同步</li>
<li>防止指令重排序</li>
</ul>
</li>
<li><p>GC的分代回收</p>
</li>
<li><p>G1垃圾回收算法与CMS的区别有哪些？</p>
</li>
<li><p>对象引用有哪几种方式，有什么特点</p>
<ul>
<li>强引用</li>
<li>弱引用</li>
<li>软引用</li>
<li>虚引用</li>
</ul>
</li>
<li><p>使用过那些JVM调试工具，主要分析哪些内容？</p>
</li>
</ol>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Powered By <b><a target="_blank" href="https://hexo.io/">Hexo</a></b>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

